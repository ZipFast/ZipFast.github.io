# Trie

​	Consider we want to search string key, if we store keys in binary search tree, then the time complexity is $O(MlogN)$, M is the average length of the key, and N is the number of the keys. (Because we must search the node and compare the string in the node with the desire key).

​	We can achieve $O(M)$ time by using trie tree.

​	the root of trie is always the blank, 每个节点都包含多个分支，用isEndOfWord来标识词尾的字母。

#include <bits/stdc++.h>
using namespace std;

class Trie {
public:
	class TrieNode {
	public:
		// 提供大小为26个空位的children数组，对应26个字母
		vector<TrieNode *> children;
		// 标识是否为单词结尾的node
		bool isEndOfWord;
		TrieNode(bool f): isEndOfWord(f), children(vector<TrieNode *>(26, nullptr)) {}
	};
	TrieNode *root = new TrieNode(false);
	void insert(string key) {
		auto *p = root;
		for (char ch: key) {
			int index = ch - 'a';
			if (!p->children[index]) {
				p->children[index] = new TrieNode(false);
			}
			p = p->children[index];
		}
		p->isEndOfWord = true;
	}
	bool search(string key) {
		auto *p = root;
		for (char ch: key) {
			int index = ch - 'a';
			if (p->children[index]) {
				p = p->children[index];
			} else {
				return false;
			}
		}
		return p->isEndOfWord;
	}

	bool startWith(string prefix) {
		auto *p = root;
		for (char ch: prefix) {
			int index = ch - 'a';
			if (p->children[index]) {
				p = p->children[index];
			} else 
				return false;
		}
		return true;
	}
};

int main() {
	Trie *obj = new Trie();
	obj->insert("apple");
	bool param_2 = obj->search("apple");
	bool param_3 = obj->startWith("appl");
	assert(param_2);
	assert(param_3);
	return 0;
}
